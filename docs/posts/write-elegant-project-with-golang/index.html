<!DOCTYPE html>
<html lang="en" class="dark light">

    <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="base" content="https:&#x2F;&#x2F;memwey.github.io">

    

    
    
    
        <title>
            
                实现优雅的 Golang 项目结构
            
        </title>

        
            <meta property="og:title"
                  content="实现优雅的 Golang 项目结构" />
        
    

    
        
    

    
        
    

    
    

    
    
        <link href=https://memwey.github.io/fonts.css rel="stylesheet" />
    

    
    

    
    

    
    

    
    <script defer src=https://memwey.github.io/js/toc.js></script>

    
    

    

    
    


    
    
        <link rel="stylesheet"
              type="text/css"
              href="https://memwey.github.io/theme/light.css" />
        <link id="darkModeStyle"
              rel="stylesheet"
              type="text/css"
              href="https://memwey.github.io/theme/dark.css" />
    

    <!-- Set the correct theme in the script -->

    
        <script src=https://memwey.github.io/js/themetoggle.js></script>

        
            <script>setTheme(getSavedTheme());</script>
        
    


    <link rel="stylesheet"
          type="text/css"
          media="screen"
          href="https://memwey.github.io/main.css" />

    

    </head>


    <body>
        <div class="left-content">
            
            
        </div>

        <div class="content">
            <nav>
    <div class="left-nav">
        
            <a href=https:&#x2F;&#x2F;memwey.github.io></a>
        


        <div class="socials">
            
                <a rel="me" href="https:&#x2F;&#x2F;x.com&#x2F;Mem_Wey" class="social">
                    <img alt="twitter" src="https://memwey.github.io/icons/social/twitter.svg">
                </a>
            
                <a rel="me" href="https:&#x2F;&#x2F;github.com&#x2F;memwey" class="social">
                    <img alt="github" src="https://memwey.github.io/icons/social/github.svg">
                </a>
            
        </div>
    </div>

    <div class="right-nav">
        
            <a href=https://memwey.github.io/posts style="margin-right: 0.5em">&#x2F;posts</a>
        
            <a href=https://memwey.github.io/tags style="margin-right: 0.5em">&#x2F;tags</a>
        
            <a href=https://memwey.github.io/about style="margin-right: 0.5em">&#x2F;about</a>
        

        

        
            <a id="dark-mode-toggle"
            onclick="toggleTheme(); event.preventDefault();"
            href="#">
                <img src="https://memwey.github.io/icons/sun.svg"
                    id="sun-icon"
                    style="filter: invert(1)"
                    alt="Light" />
                <img src=https://memwey.github.io/icons/moon.svg id="moon-icon" alt="Dark" />
            </a>

            <!-- Initialize the theme toggle icons -->
            <script>updateItemToggleTheme()</script>
        
    </div>
</nav>


            
            
    
<div class="visible-element-observer-root" data-selector="main article p">
    <main>
        <article>
            <div class="title">
                
                
    
    <div class="page-header">
        实现优雅的 Golang 项目结构
    </div>
    


                <div class="meta">
                    
                        Posted on <time>2021-02-19</time>
                    


                    
                        :: Updated on <time>2021-02-19</time>
                    

                    

                    

                    
                    

                    
                    

                    
                    
                        <span class="tags-label"> :: </span>
                        <span class="tags">
                                <a href="https://memwey.github.io/tags/golang/"
                                   class="post-tag">Golang</a>
                            
                        </span>
                    

                    

                </div>
            </div>

            

            <section class="body">
                <p>随着工作经验的积累, 越来越感到仅仅写出 <code>Elegant Code</code> 是不够的, 特别是当多人合作开发的时候, 遇到种种结构混乱, 代码冗余, 模块耦合, 依赖耦合的问题. 这个时候, 就需要更高的要求, <code>Elegant Project</code>, 自顶向下的改善项目的结构.</p>
<p>仅仅实现业务逻辑是很容易的, 而大量的时间会用在测试, Debug 上. 一个良好定义的项目结构能够极大地提升开发效率, 降低维护成本. 下面介绍一套经过实践检验的 Go 项目结构规范.</p>
<h2 id="xiang-mu-jie-gou-gui-fan"><a class="zola-anchor" href="#xiang-mu-jie-gou-gui-fan" aria-label="Anchor link for: xiang-mu-jie-gou-gui-fan">项目结构规范</a></h2>
<h3 id="fu-wu-diao-yong-service-invocation"><a class="zola-anchor" href="#fu-wu-diao-yong-service-invocation" aria-label="Anchor link for: fu-wu-diao-yong-service-invocation">服务调用 (Service Invocation)</a></h3>
<p>项目的核心调用链遵循一个清晰的层次结构:</p>
<ol>
<li><strong>接口定义</strong>:  服务接口在 <code>./domain/&lt;service_name&gt;/domain.go</code> 文件中定义. 这是服务能力的抽象.</li>
<li><strong>服务实现</strong>:  服务的具体实现在对应的 <code>./app/&lt;service_name&gt;</code> 目录中完成.</li>
<li><strong>Web Handler</strong>:  Web Handler 实现在 <code>./internal/web</code> 目录中.</li>
<li><strong>调用流程</strong>:  Web Handler 调用 <code>./domain/&lt;service_name&gt;</code> 中定义的服务接口, 而非直接依赖具体实现.</li>
<li><strong>复杂流程处理</strong>:  对于需要调用多个服务方法的复杂业务流程, 应该在一个专用的, 以 <code>flow</code> 为后缀的服务中进行编排, 而不是直接在 Web Handler 中组合.</li>
</ol>
<h3 id="fu-wu-bao-ming-ming-service-package-name"><a class="zola-anchor" href="#fu-wu-bao-ming-ming-service-package-name" aria-label="Anchor link for: fu-wu-bao-ming-ming-service-package-name">服务包命名 (Service Package Name)</a></h3>
<ul>
<li><strong>避免服务包与它操作的实体同名</strong>:  例如, 操作 <code>User</code> 实体的服务不应该命名为 <code>user</code>.</li>
<li><strong>使用后缀来明确包的职责</strong>:  推荐使用 <code>mgr</code>, <code>hdl</code>, <code>uc</code>, <code>svc</code>, <code>flow</code> 等后缀来命名服务包, 以清晰地表达其作为服务层的角色.</li>
</ul>
<h3 id="fu-wu-fang-fa-qian-ming-service-method-signature"><a class="zola-anchor" href="#fu-wu-fang-fa-qian-ming-service-method-signature" aria-label="Anchor link for: fu-wu-fang-fa-qian-ming-service-method-signature">服务方法签名 (Service Method Signature)</a></h3>
<p>为了保持一致性和可预测性, 所有服务方法都应遵循以下签名格式:</p>
<pre data-lang="go" style="background-color:#2b303b;color:#c0c5ce;" class="language-go "><code class="language-go" data-lang="go"><span style="color:#65737e;">// 标准服务方法签名
</span><span style="color:#bf616a;">Hello</span><span>(</span><span style="color:#bf616a;">ctx context</span><span>.</span><span style="color:#bf616a;">Context</span><span>, </span><span style="color:#bf616a;">req </span><span>*</span><span style="color:#bf616a;">HelloRequest</span><span>) (</span><span style="color:#bf616a;">resp </span><span>*</span><span style="color:#bf616a;">HelloResponse</span><span>, </span><span style="color:#bf616a;">err error</span><span>)
</span></code></pre>
<ul>
<li><strong>请求/响应类型</strong>:  请求和响应的结构体遵循 <code>&lt;MethodName&gt;Request</code> 和 <code>&lt;MethodName&gt;Response</code> 的命名模式.</li>
<li><strong>上下文参数</strong>:  第一个参数必须是 <code>context.Context</code>, 用于传递请求范围的数据, 如 trace ID, 用户身份等.</li>
<li><strong>错误返回</strong>:  最后一个返回值必须是 <code>error</code>, 用于错误处理.</li>
<li><strong>命名返回值</strong>:  推荐使用命名返回值, 以增强代码的可读性.</li>
<li><strong>批量获取</strong>:  对于通过 ID 批量获取数据的方法, 方法名应为 <code>Fetch&lt;Objects&gt;Dict</code>, 且响应中应包含一个名为 <code>&lt;Objects&gt;Dict</code> 的 <code>map[&lt;IDType&gt;]&lt;Object&gt;</code> 字段, 以方便调用方通过 ID 查找对象.</li>
</ul>
<h3 id="fu-wu-shi-xian-jie-gou-service-implementation-structure"><a class="zola-anchor" href="#fu-wu-shi-xian-jie-gou-service-implementation-structure" aria-label="Anchor link for: fu-wu-shi-xian-jie-gou-service-implementation-structure">服务实现结构 (Service Implementation Structure)</a></h3>
<p>一个独立服务的内部结构组织如下:</p>
<ul>
<li><strong>服务接口</strong>:  <code>Service</code> 接口位于 <code>./domain/&lt;service_name&gt;/domain.go</code>.</li>
<li><strong>内部核心定义</strong>:  如有需要, 内部使用的数据结构和 Repository 接口定义在 <code>./app/&lt;service_name&gt;/internal/core/core.go</code>, 以 <code>core</code> 为包名.</li>
<li><strong>Repository 实现</strong>:  Repository 的具体实现放在 <code>./app/&lt;service_name&gt;/internal/repo</code> 目录中.</li>
<li><strong>服务初始化</strong>:  服务的结构体和构造逻辑, 以及传入的依赖定义在 <code>./app/&lt;service_name&gt;/service.go</code>.</li>
<li><strong>服务构造函数</strong>:  服务构造函数应命名为 <code>NewService(inj *NewServiceInj, opts ...ServiceOption) (srv *Service, err error)</code>.</li>
<li><strong>业务逻辑</strong>:  核心业务逻辑实现在 <code>./app/&lt;service_name&gt;</code> 目录下的独立文件中, 与服务构造函数分离.</li>
<li><strong>Repository 构造函数</strong>:  Repository 的构造函数和通用的事务逻辑 (如 <code>(r *Repo) WithTx(...)</code>) 应放在 <code>./app/&lt;service_name&gt;/internal/repo/repo.go</code> 中.</li>
<li><strong>Repository 操作</strong>:  Repository 的具体数据库操作在 <code>./app/&lt;service_name&gt;/internal/repo</code> 目录下的独立文件中实现, 与其构造函数分离, 以 <code>repo</code> 为包名.</li>
<li><strong>文件命名</strong>:  业务逻辑文件应根据其主要处理的实体来命名, 清晰地反映其职责.</li>
<li><strong>数据库事务边界</strong>:  数据库事务边界应定义在服务层, 而不是在 Repository 层.</li>
</ul>
<h3 id="fu-wu-mock-service-mock"><a class="zola-anchor" href="#fu-wu-mock-service-mock" aria-label="Anchor link for: fu-wu-mock-service-mock">服务 Mock (Service Mock)</a></h3>
<ul>
<li><strong>Mock 初始化</strong>:  总是使用辅助函数 <code>initMockService(t *testing.T) (srv *service.Service, mockInj *mockInjection)</code> 来初始化被测试的服务及其 mock 依赖.</li>
<li><strong>Mock 生成</strong>:  使用 <code>Mockery</code> 基于接口生成 mock 对象.</li>
<li><strong>类型安全</strong>:  测试辅助函数应使用<strong>类型安全</strong>的方法调用来设置 mock 行为, 而不是依赖于基于字符串的通用方法, 如 <code>mock.On("MethodName")</code>.</li>
</ul>
<h3 id="jiao-ben-scripts"><a class="zola-anchor" href="#jiao-ben-scripts" aria-label="Anchor link for: jiao-ben-scripts">脚本 (Scripts)</a></h3>
<ul>
<li><strong>通用脚本</strong>:  常用的脚本应放置在 <code>./script</code> 目录中.</li>
<li><strong>SQL 文件</strong>:  SQL DML 和 DDL 文件应放置在 <code>./script/sql</code> 目录中.</li>
</ul>
<h3 id="ke-xuan-shi-xian-shi-yong-ent-orm"><a class="zola-anchor" href="#ke-xuan-shi-xian-shi-yong-ent-orm" aria-label="Anchor link for: ke-xuan-shi-xian-shi-yong-ent-orm">可选实现: 使用 Ent ORM</a></h3>
<p>本结构规范不强制绑定任何 ORM 框架, 但如果选择使用 <a href="https://entgo.io/">Ent</a>, 可以遵循以下约定来更好地集成.</p>
<ul>
<li><strong>Schema 定义</strong>:  <code>Ent</code> 的 Schema 定义在 <code>./internal/schema</code> 目录中, 每个数据表对应一个文件, 如 <code>./internal/schema/user.go</code>.</li>
<li><strong>生成代码</strong>:  <code>Ent</code> 生成的代码位于 <code>./internal/ent</code> 目录.</li>
<li><strong>实体命名</strong>:  在 Repository 层, <code>Ent</code> ORM 生成的对象在命名时应使用 <code>Entity</code> (或 <code>Entities</code> 用于集合) 后缀, 以明确区分它们与领域中的 <code>core</code> 包中的实体, 并且 <code>Ent</code> 生成的对象不能泄露出 <code>repo</code> 包.</li>
<li><strong>代码生成脚本</strong>:  生成 Ent ORM 代码的脚本应位于 <code>./script/ent.sh</code>.</li>
</ul>
<h2 id="fu-wu-diao-yong-liu-cheng-tu"><a class="zola-anchor" href="#fu-wu-diao-yong-liu-cheng-tu" aria-label="Anchor link for: fu-wu-diao-yong-liu-cheng-tu">服务调用流程图</a></h2>
<p>下图展示了从接收客户端请求到与数据库交互的完整分层调用链, 它强调了接口与实现分离 (依赖倒置原则), 以及各层在项目中的位置. 这样保证了每一个层级的职责清晰, 耦合度低, 方便维护和扩展, 也方便进行单元测试和排查问题.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>[ API Request ]
</span><span>      |
</span><span>      v
</span><span>+--------------------------------+
</span><span>|      Web Handler               |
</span><span>|     (./internal/web)           |
</span><span>+--------------------------------+
</span><span>      |
</span><span>      |  (依赖接口)
</span><span>      v
</span><span>+--------------------------------+ &lt;----+
</span><span>|      Domain Interface          |      |
</span><span>|   (./domain/&lt;service_name&gt;)    |      | (服务之间通过接口调用)
</span><span>+--------------------------------+      |
</span><span>      |                                  
</span><span>      |  (由 App 层实现)
</span><span>      v
</span><span>+--------------------------------+      |
</span><span>|      App Implementation        | -----+
</span><span>|    (./app/&lt;service_name&gt;)      |
</span><span>+--------------------------------+
</span><span>      |
</span><span>      |  (依赖接口)
</span><span>      v
</span><span>+--------------------------------+
</span><span>|      Repository Interface      |
</span><span>|   (./app/.../internal/core)    |
</span><span>+--------------------------------+
</span><span>      |
</span><span>      |  (由 Repo 层实现)
</span><span>      v
</span><span>+--------------------------------+
</span><span>|      Repository Implementation |
</span><span>|   (./app/.../internal/repo)    |
</span><span>+--------------------------------+
</span><span>      |
</span><span>      v
</span><span>[ Database / ORM ]
</span></code></pre>
<h2 id="shi-li-xiang-mu-mu-lu-jie-gou"><a class="zola-anchor" href="#shi-li-xiang-mu-mu-lu-jie-gou" aria-label="Anchor link for: shi-li-xiang-mu-mu-lu-jie-gou">示例项目目录结构</a></h2>
<p>这是一个遵循上述规范的示例项目结构. 它以一个用户注册场景为例, 其中 <code>registrationflow</code> 是一个复杂流程, 负责编排 <code>authuc</code> (认证用例) 和 <code>notiuc</code> (通知用例).</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>/
</span><span>├── app/
</span><span>│   ├── registrationflow/           # “用户注册”流程的实现
</span><span>│   │   ├── service.go              # 定义 Service, NewService
</span><span>│   │   └── registration_logic.go   # 流程编排逻辑
</span><span>│   ├── authuc/                     # “认证”用例的实现
</span><span>│   │   ├── internal/
</span><span>│   │   │   ├── core/
</span><span>│   │   │   │   ├── core.go         # 定义 IAuthRepo 使用的数据结构
</span><span>│   │   │   │   └── repo_mock.go    # IAuthRepo 的 mock 实现
</span><span>│   │   │   └── repo/
</span><span>│   │   │       ├── repo.go         # 定义 Repo, NewRepo, WithTx
</span><span>│   │   │       └── auth_repo.go    # 实现 IAuthRepo
</span><span>│   │   ├── service.go              # 定义 Service, NewService
</span><span>│   │   ├── auth_logic.go           # 认证业务逻辑
</span><span>│   │   └── auth_logic_test.go      # 认证业务逻辑的单元测试
</span><span>│   └── notiuc/                     # “通知”用例的实现
</span><span>│       ├── internal/               # (可选, 如需封装 client 或定义内部结构)
</span><span>│       │   └── ...
</span><span>│       ├── service.go              # 定义 Service, NewService
</span><span>│       └── noti_logic.go           # 通知业务逻辑 (如发邮件, 短信)
</span><span>├── cmd/
</span><span>│   └── server/
</span><span>│       └── main.go
</span><span>├── domain/
</span><span>│   ├── registrationflow/
</span><span>│   │   ├── domain.go               # 定义 RegistrationFlow 接口
</span><span>│   │   └── service_mock.go         # RegistrationFlow 的 mock 实现
</span><span>│   ├── authuc/
</span><span>│   │   ├── domain.go               # 定义 AuthUseCase 接口
</span><span>│   │   └── service_mock.go         # AuthUseCase 的 mock 实现
</span><span>│   └── notiuc/
</span><span>│       ├── domain.go               # 定义 NotiUseCase 接口
</span><span>│       └── service_mock.go         # NotiUseCase 的 mock 实现
</span><span>├── internal/
</span><span>│   └── web/
</span><span>│       ├── registration_handler.go # 处理注册流程, 调用 domain/registrationflow
</span><span>│       ├── auth_handler.go         # 处理认证请求, 调用 domain/authuc
</span><span>│       └── auth_handler_test.go    # 认证请求处理的单元测试
</span><span>...
</span></code></pre>
<p>上述目录结构展示了一个典型的分层应用:</p>
<ul>
<li><strong><code>domain</code></strong>:  定义了三个核心服务接口: <code>RegistrationFlow</code>、<code>AuthUseCase</code> 和 <code>NotiUseCase</code>. 这是业务能力的抽象层.</li>
<li><strong><code>app</code></strong>:  包含了上述接口的具体实现. <code>registrationflow</code> 是一个流程服务 (Flow), 它的实现会依赖 <code>authuc</code> 和 <code>notiuc</code> 的接口, 从而编排和调用这两个用例服务.</li>
<li><strong><code>internal/web</code></strong>:  Web Handler 层, 负责暴露服务给外部. 不同的 Handler 文件处理不同的业务, 例如 <code>registration_handler.go</code> 调用复杂的流程服务, 而 <code>auth_handler.go</code>可以直接调用简单的用例服务.</li>
<li><strong>包命名</strong>:  注意所有包名都使用简短, 全小写的形式, 并且不使用下划线, 这是 Go 语言推荐的风格.</li>
<li><strong>Mock 与测试</strong>:
<ul>
<li><strong>Mock 文件</strong>: <code>*_mock.go</code> 是接口的 mock 实现, 用于单元测试.</li>
<li><strong>测试文件</strong>: <code>*_test.go</code> 是对应的单元测试文件.</li>
<li><strong>依赖关系</strong>: 基于依赖倒置原则, 测试文件会使用 mock 来隔离被测试的层级.
<ul>
<li><code>app/authuc/auth_logic_test.go</code> (业务逻辑测试) 会使用 <code>app/authuc/internal/core/repo_mock.go</code> 来模拟数据访问行为.</li>
<li><code>internal/web/auth_handler_test.go</code> (Handler 测试) 会使用 <code>domain/authuc/service_mock.go</code> 来模拟业务服务行为.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="zong-jie"><a class="zola-anchor" href="#zong-jie" aria-label="Anchor link for: zong-jie">总结</a></h2>
<p>本规范的核心价值在于提供一个清晰一致的项目结构, 从而提升项目的<strong>可测试性</strong>和<strong>可维护性</strong>. 通过明确的分层和接口定义, 实现了以下关键的架构原则:</p>
<ul>
<li><strong>Monorepo 下的微服务化</strong>: 在单一代码库(Monorepo)中, 通过模块化的服务(<code>app</code>)和统一的接口(<code>domain</code>), 实现了类似微服务的开发体验. 每个服务都可以独立开发, 测试和部署, 但又能在同一个项目中轻松共享代码和配置.</li>
<li><strong>支持多人协作</strong>: 清晰的边界和所有权使得多个开发团队可以并行工作, 而不会相互干扰. 每个团队可以专注于自己的服务, 并通过定义好的接口进行协作.</li>
<li><strong>高可测试性</strong>: 依赖倒置原则的贯彻, 以及接口 mock 的普遍使用, 使得每个模块都可以进行独立的单元测试, 保证了代码质量和迭代速度.</li>
</ul>
<h2 id="can-kao-lian-jie"><a class="zola-anchor" href="#can-kao-lian-jie" aria-label="Anchor link for: can-kao-lian-jie">参考链接</a></h2>
<ul>
<li><a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a></li>
<li><a href="https://github.com/mattermost/mattermost">Mattermost</a></li>
</ul>

            </section>
        </article>
    </main>
</div>



            
                
            

            
        </div>

        <div class="right-content">
            
    
    
        <div class="toc">
    <div class="heading">Table of Contents</div>
    <ul class="toc-list">
        
            <li class="parent">
                
                <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#xiang-mu-jie-gou-gui-fan">项目结构规范</a>

                
                    <ul>
                    
                        
                        <li>
                            <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#fu-wu-diao-yong-service-invocation">服务调用 (Service Invocation)</a>
                        </li>

                        
                    
                        
                        <li>
                            <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#fu-wu-bao-ming-ming-service-package-name">服务包命名 (Service Package Name)</a>
                        </li>

                        
                    
                        
                        <li>
                            <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#fu-wu-fang-fa-qian-ming-service-method-signature">服务方法签名 (Service Method Signature)</a>
                        </li>

                        
                    
                        
                        <li>
                            <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#fu-wu-shi-xian-jie-gou-service-implementation-structure">服务实现结构 (Service Implementation Structure)</a>
                        </li>

                        
                    
                        
                        <li>
                            <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#fu-wu-mock-service-mock">服务 Mock (Service Mock)</a>
                        </li>

                        
                    
                        
                        <li>
                            <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#jiao-ben-scripts">脚本 (Scripts)</a>
                        </li>

                        
                    
                        
                        <li>
                            <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#ke-xuan-shi-xian-shi-yong-ent-orm">可选实现: 使用 Ent ORM</a>
                        </li>

                        
                    
                    </ul>
                
            </li>
        
            <li class="parent">
                
                <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#fu-wu-diao-yong-liu-cheng-tu">服务调用流程图</a>

                
            </li>
        
            <li class="parent">
                
                <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#shi-li-xiang-mu-mu-lu-jie-gou">示例项目目录结构</a>

                
            </li>
        
            <li class="parent">
                
                <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#zong-jie">总结</a>

                
            </li>
        
            <li class="parent">
                
                <a href="https://memwey.github.io/posts/write-elegant-project-with-golang/#can-kao-lian-jie">参考链接</a>

                
            </li>
        
    </ul>
</div>

    

        </div>
    </body>

</html>
