<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://memwey.github.io name=base><title>
            
                Prometheus 手把手
            
        </title><meta content="Prometheus 手把手" property=og:title><meta content="面向开发, 手把手教还不会的话, 直接打死" property=og:description><meta content="面向开发, 手把手教还不会的话, 直接打死" name=description><link href=https://memwey.github.io/fonts.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-VLQ5DBCKGT" async></script><script>window.dataLayer = window.dataLayer || [];

                function gtag() {
                    dataLayer.push(arguments);
                }
                gtag('js', new Date());
                gtag('config', 'G-VLQ5DBCKGT');</script><script defer src=https://memwey.github.io/js/toc.js></script><link title="
    Mem.Wey's Github Pages
" href=https://memwey.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://memwey.github.io/theme/light.css rel=stylesheet><link href=https://memwey.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://memwey.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://memwey.github.io/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://memwey.github.io>Mem.Wey's Github Pages</a><div class=socials><a rel="'me'" class=social href=https://x.com/Mem_Wey> <img alt=twitter src=https://memwey.github.io/icons/social/twitter.svg> </a><a rel="'me'" class=social href=https://github.com/memwey> <img alt=github src=https://memwey.github.io/icons/social/github.svg> </a></div></div><div class=right-nav><a href=https://memwey.github.io/posts style=margin-right:.5em>/posts</a><a href=https://memwey.github.io/tags style=margin-right:.5em>/tags</a><a href=https://memwey.github.io/about style=margin-right:.5em>/about</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://memwey.github.io/icons/sun.svg> <img alt=Dark id=moon-icon src=https://memwey.github.io/icons/moon.svg style=filter:invert()> <img alt=Auto id=auto-icon src=https://memwey.github.io/icons/auto.svg style=filter:invert()> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Prometheus 手把手</div><div class=meta>Posted on <time>2022-05-10</time><span class=tags-label>::</span><span class=tags> <a class=post-tag href=https://memwey.github.io/tags/prometheus/>Prometheus</a> <a class=post-tag href=https://memwey.github.io/tags/database/>Database</a> </span></div></div><section class=body><p>因为 Prometheus 在应用中一共只有四种 metric 类型, 只要根据需要监测的目标选择了 metrics 类型, 后续的告警以及可视化配置就有固定的套路了.<h3 id=counter><a aria-label="Anchor link for: counter" class=zola-anchor href=#counter>Counter</a></h3><p>Counter 用来监控单调递增的量, 当发生重置时 Prometheus 会自动处理归零的数据. 这是一个非常基本的类型, 一个系统中很多数据都可以通过此类型进行计数, 比如系统接受的请求数, 系统发生的错误数, 再比如对第三方接口的调用数, 第三方接口返回的错误数.<p>业务代码如下<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>from </span><span>prometheus_client </span><span style=color:#b48ead>import </span><span>Counter
</span><span>c = </span><span style=color:#bf616a>Counter</span><span>(
</span><span>    '</span><span style=color:#a3be8c>web_request_total</span><span>', '</span><span style=color:#a3be8c>web request total counter</span><span>',
</span><span>    ['</span><span style=color:#a3be8c>method</span><span>', '</span><span style=color:#a3be8c>endpoint</span><span>', '</span><span style=color:#a3be8c>status_code</span><span>']
</span><span>)
</span><span>c.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>get</span><span>', '</span><span style=color:#a3be8c>/</span><span>', '</span><span style=color:#a3be8c>200</span><span>').</span><span style=color:#bf616a>inc</span><span>()
</span><span>c.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>post</span><span>', '</span><span style=color:#a3be8c>/submit</span><span>', '</span><span style=color:#a3be8c>500</span><span>').</span><span style=color:#bf616a>inc</span><span>()
</span></code></pre><p>此时在业务暴露出来的端点上会有这样两条记录<pre style=color:#c0c5ce;background-color:#2b303b><code><span>web_request_total{method="/submit",method="post",status_code="500"} 1
</span><span>web_request_total{method="/",method="get",status_code="200"} 1
</span></code></pre><p>对于 Counter 我们一般看增长量和增长速率<ul><li><code>sum(increase(web_request_total[5m]))</code> 五分钟内总请求数<li><code>sum(increase(web_request_total{status_code!~"^2.."}[1m]))</code> 一分钟内状态码不为2xx的总请求数<li><code>sum(irate(web_request_total[1m]))</code> 一分钟内总请求数增长率</ul><p>告警则一般设置为<ul><li>一分钟内总请求中有有超过 5% 的 5xx 错误, 持续一分钟</ul><pre style=color:#c0c5ce;background-color:#2b303b><code><span>expr: sum(rate(web_request_total{status_code=~"^5.."}[1m])) / sum(rate(web_request_total[1m])) * 100 > 5
</span><span>for: 1m
</span></code></pre><ul><li>一分钟内 5xx 错误的请求增长率高于 100%, 持续一分钟</ul><pre style=color:#c0c5ce;background-color:#2b303b><code><span>expr: sum(irate(web_request_total{status_code=~"^5.."}[1m])) > 100
</span><span>for: 1m
</span></code></pre><h3 id=gauge><a aria-label="Anchor link for: gauge" class=zola-anchor href=#gauge>Gauge</a></h3><p>Gauge 是一个瞬时量, 在时间上来看是可增可减的, 用以记录系统在某个时刻的当前状态, 比如当前实例线程数, 当前系统负载, 某个队列的长度, 某个队列的消费延时等.<p>业务代码如下<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>from </span><span>prometheus_client </span><span style=color:#b48ead>import </span><span>Gauge
</span><span>g1 = </span><span style=color:#bf616a>Gauge</span><span>(
</span><span>    '</span><span style=color:#a3be8c>kafka_consumer_lag_seconds</span><span>', '</span><span style=color:#a3be8c>kafka consume lag in second</span><span>',
</span><span>    ['</span><span style=color:#a3be8c>topic</span><span>', '</span><span style=color:#a3be8c>consumer_group</span><span>']
</span><span>)
</span><span>g1.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>k-test</span><span>', '</span><span style=color:#a3be8c>grp1</span><span>').</span><span style=color:#bf616a>set</span><span>(</span><span style=color:#d08770>233</span><span>)
</span><span>g2 = </span><span style=color:#bf616a>Gauge</span><span>(
</span><span>    '</span><span style=color:#a3be8c>redis_connection_pool_count</span><span>', '</span><span style=color:#a3be8c>redis connection poll count</span><span>',
</span><span>    ['</span><span style=color:#a3be8c>state</span><span>']
</span><span>)
</span><span>g2.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>idle</span><span>').</span><span style=color:#bf616a>set</span><span>(</span><span style=color:#d08770>10</span><span>)
</span><span>g2.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>active</span><span>').</span><span style=color:#bf616a>set</span><span>(</span><span style=color:#d08770>22</span><span>)
</span><span>g2.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>total</span><span>').</span><span style=color:#bf616a>set</span><span>(</span><span style=color:#d08770>32</span><span>)
</span></code></pre><p>此时在业务暴露出来的端点上会有这样的记录<pre style=color:#c0c5ce;background-color:#2b303b><code><span>kafka_consumer_lag_seconds{topic="k-test",consumer_group="grp1"} 233
</span><span>redis_connection_pool_count{state="idle"} 10
</span><span>redis_connection_pool_count{state="active"} 22
</span><span>redis_connection_pool_count{state="total"} 32
</span></code></pre><p>对于 Gauge 我们一般直接看其值或者其值的百分比<ul><li><p><code>kafka_consumer_lag_seconds{topic="k-test"}</code> 查看 k-test 这个 topic 最新的消费延迟</p><li><p><code>avg_over_time(kafka_consumer_lag_seconds[1m])</code> 查看应用全部 kafka 队列一分钟的平均消费延时</p><li><p><code>max_over_time(kafka_consumer_lag_seconds[1m])</code> 查看应用全部 kafka 队列每一分钟内的最大消费延时</p><li><p><code>redis_connection_pool_count{state="active"} / ignoring(state) redis_connection_pool_count{state="total"}</code> 查看应用 redis 连接池的使用百分比</p></ul><p>告警则一般设置为<ul><li>一分钟内队列的平均消费延时大于 10min, 持续一分钟</ul><pre style=color:#c0c5ce;background-color:#2b303b><code><span>expr: avg_over_time(kafka_consumer_lag_seconds[1m]) > 600
</span><span>for: 1m
</span></code></pre><ul><li>Redis 连接池平均占用超过 90%, 持续一分钟</ul><pre style=color:#c0c5ce;background-color:#2b303b><code><span>expr: avg_over_time(redis_connection_pool_count{state="active"}[1m]) /  ignoring(state) avg_over_time(redis_connection_pool_count{state="total"}[1m]) * 100 > 90
</span><span>for: 1m
</span></code></pre><h3 id=histogram-he-summary><a aria-label="Anchor link for: histogram-he-summary" class=zola-anchor href=#histogram-he-summary>Histogram 和 Summary</a></h3><p>Histogram 可以看作是一个复合的 Counter 类型, 它会将数值按区间计数, 常用于记录 P99, P95 类的数据. 可以用来记录比如接口响应耗时情况, 接口返回数据大小情况等.<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>from </span><span>prometheus_client </span><span style=color:#b48ead>import </span><span>Histogram
</span><span>h = </span><span style=color:#bf616a>Histogram</span><span>(
</span><span>    '</span><span style=color:#a3be8c>http_request_duration_seconds</span><span>', '</span><span style=color:#a3be8c>Api requests response time in seconds</span><span>',
</span><span>    ['</span><span style=color:#a3be8c>api</span><span>', '</span><span style=color:#a3be8c>method</span><span>'], (</span><span style=color:#d08770>0.1</span><span>, </span><span style=color:#d08770>0.25</span><span>, </span><span style=color:#d08770>1</span><span>, </span><span style=color:#d08770>4</span><span>, </span><span style=color:#d08770>10</span><span>)
</span><span>)
</span><span>h.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>/products</span><span>', '</span><span style=color:#a3be8c>post</span><span>').</span><span style=color:#bf616a>observe</span><span>(</span><span style=color:#d08770>0.0923</span><span>)
</span><span>h.</span><span style=color:#bf616a>labels</span><span>('</span><span style=color:#a3be8c>/products</span><span>', '</span><span style=color:#a3be8c>post</span><span>').</span><span style=color:#bf616a>observe</span><span>(</span><span style=color:#d08770>0.3672</span><span>)
</span></code></pre><p>此时在业务暴露出来的端点上会有这样的记录, 产生了多条数据, 其中 <code>_sum</code> 是值的总和, <code>_count</code> 是值的计数, <code>_bucket</code> 中有一个命名为 <code>le</code> 特殊的 label, 其中的区间值是我们在代码中配置的, 是值在区间内的计数.<pre style=color:#c0c5ce;background-color:#2b303b><code><span>http_request_duration_seconds_sum{api="/products", "method"="post"} 0.4595
</span><span>http_request_duration_seconds_count{api="/products", "method"="post"} 2
</span><span>http_request_duration_seconds_bucket{api="/products", "method"="post", le="0.1"} 1
</span><span>http_request_duration_seconds_bucket{api="/products", "method"="post", le="0.25"} 1
</span><span>http_request_duration_seconds_bucket{api="/products", "method"="post", le="1"} 2
</span><span>http_request_duration_seconds_bucket{api="/products", "method"="post", le="4"} 2
</span><span>http_request_duration_seconds_bucket{api="/products", "method"="post", le="10"} 2
</span><span>http_request_duration_seconds_bucket{api="/products", "method"="post", le="+Inf"} 2
</span></code></pre><p>对于 Histogram 一般可以求均值或者 P95, P99 之类的值, 也可以做普通的 Counter 使用<ul><li><code>rate(http_request_duration_seconds_sum{api="/products", "method"="post"}[5m]) / rate(http_request_duration_seconds_count{api="/products", "method"="post"}[5m])</code> 查看 /products 端点上 POST 请求五分钟内的耗时均值<li><code>histogram_quantile(0.99, rate(http_request_duration_seconds_bucket{api="/products", "method"="post"}[5m]))</code> 查看 /products 端点上 POST 请求五分钟内的耗时 P99<li><code>increase(http_request_duration_seconds_count{api="/products", "method"="post"}[1m])</code> 查看 /products 端点上 POST 请求一分钟内的请求数</ul><p>告警则一般设置为<ul><li>两分钟内某个接口 P95 大于 10s, 持续两分钟</ul><pre style=color:#c0c5ce;background-color:#2b303b><code><span>expr: histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[2m])) by (api, method)) > 10
</span><span>for: 2m
</span></code></pre><p>一些有用的资料<ul><li><a href=https://awesome-prometheus-alerts.grep.to/rules>awesome-prometheus-alerts</a><li><a href=https://grafana.com/blog/2020/06/23/how-to-visualize-prometheus-histograms-in-grafana/>How to visualize Prometheus histograms in Grafana</a></ul></section></article></main></div></div><div class=right-content><div class=toc><div class=heading>Table of Contents</div><ul class=toc-list><li class=parent><a href=https://memwey.github.io/posts/prometheus-hand-over-hand/#counter>Counter</a><li class=parent><a href=https://memwey.github.io/posts/prometheus-hand-over-hand/#gauge>Gauge</a><li class=parent><a href=https://memwey.github.io/posts/prometheus-hand-over-hand/#histogram-he-summary>Histogram 和 Summary</a></ul></div></div>