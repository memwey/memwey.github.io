<!doctype html><html class="dark light" lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://memwey.github.io name=base><title>
            
                Redis ZINTERSTORE
            
        </title><meta content="Redis ZINTERSTORE" property=og:title><meta content="Tsukkomi Lolicon's GitHub Pages Blog" property=og:description><meta content="Tsukkomi Lolicon's GitHub Pages Blog" name=description><link href=https://memwey.github.io/fonts.css rel=stylesheet><script src="https://www.googletagmanager.com/gtag/js?id=G-VLQ5DBCKGT" async></script><script>window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());
                gtag('config', 'G-VLQ5DBCKGT');</script><script defer src=https://memwey.github.io/js/toc.js></script><link title="
    Mem.Wey's Github Pages
" href=https://memwey.github.io/atom.xml rel=alternate type=application/atom+xml><link href=https://memwey.github.io/theme/light.css rel=stylesheet><link href=https://memwey.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://memwey.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme());</script><link href=https://memwey.github.io/main.css media=screen rel=stylesheet><body><div class=left-content></div><div class=content><nav><div class=left-nav><a href=https://memwey.github.io>Mem.Wey's Github Pages</a><div class=socials><a rel='"me"' class=social href=https://x.com/Mem_Wey> <img alt=twitter src=https://memwey.github.io/icons/social/twitter.svg> </a><a rel='"me"' class=social href=https://github.com/memwey> <img alt=github src=https://memwey.github.io/icons/social/github.svg> </a></div></div><div class=right-nav><a href=https://memwey.github.io/posts style=margin-right:.5em>/posts</a><a href=https://memwey.github.io/tags style=margin-right:.5em>/tags</a><a href=https://memwey.github.io/about style=margin-right:.5em>/about</a><a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://memwey.github.io/icons/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://memwey.github.io/icons/moon.svg> </a><script>updateItemToggleTheme()</script></div></nav><div data-selector="main article p" class=visible-element-observer-root><main><article><div class=title><div class=page-header>Redis ZINTERSTORE</div><div class=meta>Posted on <time>2021-04-21</time> :: Updated on <time>2021-04-21</time><span class=tags-label>::</span><span class=tags> <a class=post-tag href=https://memwey.github.io/tags/redis/>Redis</a> <a class=post-tag href=https://memwey.github.io/tags/database/>Database</a> </span></div></div><section class=body><h2 id=jie-gou-tui-ce><a aria-label="Anchor link for: jie-gou-tui-ce" class=zola-anchor href=#jie-gou-tui-ce>结构推测</a></h2><p>今天与人争执的时候觉得应该探究一下 <code>Redis</code> 中 <code>ZINTERSTORE</code> 的实现. 先看文档中的描述<blockquote><p>ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</blockquote><blockquote><p>Available since 2.0.0.<p>Time complexity: O(N<em>K)+O(M</em>log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.</blockquote><p>大致意思就是最坏情况下时间复杂度是 <code>O(N*K)+O(M*log(M))</code>, 其中 <code>N</code> 是输入中元素最少的 <code>sorted set</code> 的元素数目, <code>K</code> 是输入的 <code>sorted set</code> 的数量, <code>M</code> 是结果中的 <code>sorted set</code> 中元素的数目.<p>其实光从时间复杂度就能推测出来大致的操作了. <code>O(M*log(M))</code> 这个复杂度很有可能是一次排序操作, 而且和结果中的元素数目相关, 那么很有可能是先取交集之后得出 <code>M</code> 个元素, 再在 <code>M</code> 个元素中进行排序的. 当然, 也有可能是相应的, 在有序的序列中进行插入的操作.<p>而 <code>N</code> 是最小的 <code>sorted set</code> 的元素个数. 这个一开始我有点想不明白, 难道不应该是最大的才对吗, 因为这里我还是想着去遍历其他的 <code>sorted set</code> 进行比较. 但是思考一下, <code>sorted set</code> 也是 <code>set</code> 嘛, 完全可以使用 <code>O(1)</code> 的效率在其中进行查找. 这样实际就变成了分别在 (K - 1) 个 <code>sorted set</code> 中寻找 <code>N</code> 个元素, 这样自然就是 <code>O(N*K)</code> 了.<h2 id=yuan-ma-fen-xi><a aria-label="Anchor link for: yuan-ma-fen-xi" class=zola-anchor href=#yuan-ma-fen-xi>源码分析</a></h2><p>以下源码基于 <code>Redis 3.0</code> 分析, 实际的函数操作为<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#65737e>/* https://github.com/redis/redis/blob/3.0/src/t_zset.c#L1905 */
</span><span style=color:#b48ead>void </span><span style=color:#8fa1b3>zunionInterGenericCommand</span><span>(redisClient *</span><span style=color:#bf616a>c</span><span>, robj *</span><span style=color:#bf616a>dstkey</span><span>, </span><span style=color:#b48ead>int </span><span style=color:#bf616a>op</span><span>)
</span></code></pre><p>这里我们可以看到, 在 <code>Redis</code> 的源码中将 <code>ZINTERSTORE</code> 和 <code>ZUNIONSTORE</code> 放在了一起处理, 使用 <code>op</code> 做区分.<p>随后是一段漫长的代码, 主要是处理输入参数的, 比如要操作的 <code>sorted set</code> 的列表, 存到了 <code>src</code> 中; 然后处理 <code>WEIGHTS</code> 和 <code>AGGREGATE</code>. 代码比较长而且逻辑也很简单.<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#65737e>/* https://github.com/redis/redis/blob/3.0/src/t_zset.c#L1993 */
</span><span>
</span><span>    </span><span style=color:#65737e>/* sort sets from the smallest to largest, this will improve our
</span><span style=color:#65737e>     * algorithm's performance */
</span><span>    </span><span style=color:#bf616a>qsort</span><span>(src,setnum,sizeof(zsetopsrc),zuiCompareByCardinality);
</span></code></pre><p>然后这里把所有 <code>sorted set</code> 按元素的个数从小到大排列, 以提高效率. 随后是具体的取交集的代码.<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#65737e>/* https://github.com/redis/redis/blob/3.0/src/t_zset.c#L2001 */
</span><span>
</span><span>    </span><span style=color:#b48ead>if </span><span>(op == REDIS_OP_INTER) {
</span><span>        </span><span style=color:#65737e>/* Skip everything if the smallest input is empty. */
</span><span>        </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>zuiLength</span><span>(&src[</span><span style=color:#d08770>0</span><span>]) > </span><span style=color:#d08770>0</span><span>) {
</span><span>            </span><span style=color:#65737e>/* Precondition: as src[0] is non-empty and the inputs are ordered
</span><span style=color:#65737e>             * by size, all src[i > 0] are non-empty too. */
</span><span>            </span><span style=color:#bf616a>zuiInitIterator</span><span>(&src[</span><span style=color:#d08770>0</span><span>]);
</span><span>            </span><span style=color:#b48ead>while </span><span>(</span><span style=color:#bf616a>zuiNext</span><span>(&src[</span><span style=color:#d08770>0</span><span>],&zval)) {
</span><span>                </span><span style=color:#b48ead>double</span><span> score, value;
</span><span>
</span><span>                score = src[</span><span style=color:#d08770>0</span><span>].</span><span style=color:#bf616a>weight </span><span>* zval.</span><span style=color:#bf616a>score</span><span>;
</span><span>                </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#96b5b4>isnan</span><span>(score)) score = </span><span style=color:#d08770>0</span><span>;
</span><span>
</span><span>                </span><span style=color:#b48ead>for </span><span>(j = </span><span style=color:#d08770>1</span><span>; j &lt; setnum; j++) {
</span><span>                    </span><span style=color:#65737e>/* It is not safe to access the zset we are
</span><span style=color:#65737e>                     * iterating, so explicitly check for equal object. */
</span><span>                    </span><span style=color:#b48ead>if </span><span>(src[j].</span><span style=color:#bf616a>subject </span><span>== src[</span><span style=color:#d08770>0</span><span>].</span><span style=color:#bf616a>subject</span><span>) {
</span><span>                        value = zval.</span><span style=color:#bf616a>score</span><span>*src[j].</span><span style=color:#bf616a>weight</span><span>;
</span><span>                        </span><span style=color:#bf616a>zunionInterAggregate</span><span>(&score,value,aggregate);
</span><span>                    } </span><span style=color:#b48ead>else if </span><span>(</span><span style=color:#bf616a>zuiFind</span><span>(&src[j],&zval,&value)) {
</span><span>                        value *= src[j].</span><span style=color:#bf616a>weight</span><span>;
</span><span>                        </span><span style=color:#bf616a>zunionInterAggregate</span><span>(&score,value,aggregate);
</span><span>                    } </span><span style=color:#b48ead>else </span><span>{
</span><span>                        </span><span style=color:#b48ead>break</span><span>;
</span><span>                    }
</span><span>                }
</span><span>
</span><span>                </span><span style=color:#65737e>/* Only continue when present in every input. */
</span><span>                </span><span style=color:#b48ead>if </span><span>(j == setnum) {
</span><span>                    tmp = </span><span style=color:#bf616a>zuiObjectFromValue</span><span>(&zval);
</span><span>                    znode = </span><span style=color:#bf616a>zslInsert</span><span>(dstzset->zsl,score,tmp);
</span><span>                    </span><span style=color:#bf616a>incrRefCount</span><span>(tmp); </span><span style=color:#65737e>/* added to skiplist */
</span><span>                    </span><span style=color:#bf616a>dictAdd</span><span>(dstzset->dict,tmp,&znode->score);
</span><span>                    </span><span style=color:#bf616a>incrRefCount</span><span>(tmp); </span><span style=color:#65737e>/* added to dictionary */
</span><span>
</span><span>                    </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>sdsEncodedObject</span><span>(tmp)) {
</span><span>                        </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>sdslen</span><span>(tmp->ptr) > maxelelen)
</span><span>                            maxelelen = </span><span style=color:#bf616a>sdslen</span><span>(tmp->ptr);
</span><span>                    }
</span><span>                }
</span><span>            }
</span><span>            </span><span style=color:#bf616a>zuiClearIterator</span><span>(&src[</span><span style=color:#d08770>0</span><span>]);
</span><span>        }
</span><span>    }
</span><span>
</span></code></pre><p>当然, 如果按元素数从小到大排序的第一个 <code>sorted set</code> 元素数为 0, 那就可以直接返回了, 随后在此 <code>sorted set</code> 上建立一个 <code>Iterator</code>, 主要就是帮助在 <code>sorted set</code> 上做遍历的, 因为在 <code>sorted set</code> 中, 遍历不是一个常用操作, 排序才是.<p>然后就是通过 <code>while (zuiNext(&src[0],&zval))</code> 取出第一个 <code>sorted set</code> 中的每一个元素, 再用 <code>for (j = 1; j &lt; setnum; j++)</code> 将其在每一个其他的 <code>sorted set</code> 中查找一遍.<p>当两个 <code>sorted set</code> 指向同一个对象是, 那么毫无疑问一定会有同样的元素. 否则就在 <code>src[j]</code> 中查找当前元素. <code>zuiFind(&src[j],&zval,&value)</code> 实现了这个操作. 具体的代码在后面分析. 如果找不到的话, 则没有必要继续找下去了, 跳出即可.<p>查找的过程中也使用了 <code>zunionInterAggregate(&score,value,aggregate)</code> 来更新当前元素的 <code>score</code>, 具体的 <code>score</code> 更新规则是根据 <code>AGGREGATE</code> 参数来定的.<p>当元素在所有的 <code>sorted set</code> 中时, 就可以把这个元素添加进结果的 <code>sorted set</code> 中了. 这里就是根据 <code>zval</code> 和 <code>score</code> 往 <code>dstzset</code> 里面插入元素. 因为 <code>sorted set</code> 里面既有 <code>dict</code> 也有 <code>skiplist</code>, 所以两个都要添加.<p>这里还有一个操作就是更新最大元素的长度, 这个和 <code>sorted set</code> 的内部优化有关.<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#65737e>/* https://github.com/redis/redis/blob/3.0/src/t_zset.c#L2119 */
</span><span>
</span><span>    </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>dbDelete</span><span>(c->db,dstkey)) {
</span><span>        </span><span style=color:#bf616a>signalModifiedKey</span><span>(c->db,dstkey);
</span><span>        touched = </span><span style=color:#d08770>1</span><span>;
</span><span>        server.</span><span style=color:#bf616a>dirty</span><span>++;
</span><span>    }
</span><span>    </span><span style=color:#b48ead>if </span><span>(dstzset->zsl->length) {
</span><span>        </span><span style=color:#65737e>/* Convert to ziplist when in limits. */
</span><span>        </span><span style=color:#b48ead>if </span><span>(dstzset->zsl->length &lt;= server.</span><span style=color:#bf616a>zset_max_ziplist_entries </span><span>&&
</span><span>            maxelelen &lt;= server.</span><span style=color:#bf616a>zset_max_ziplist_value</span><span>)
</span><span>                </span><span style=color:#bf616a>zsetConvert</span><span>(dstobj,REDIS_ENCODING_ZIPLIST);
</span><span>
</span><span>        </span><span style=color:#bf616a>dbAdd</span><span>(c->db,dstkey,dstobj);
</span><span>        </span><span style=color:#bf616a>addReplyLongLong</span><span>(c,</span><span style=color:#bf616a>zsetLength</span><span>(dstobj));
</span><span>        </span><span style=color:#b48ead>if </span><span>(!touched) </span><span style=color:#bf616a>signalModifiedKey</span><span>(c->db,dstkey);
</span><span>        </span><span style=color:#bf616a>notifyKeyspaceEvent</span><span>(REDIS_NOTIFY_ZSET,
</span><span>            (op == REDIS_OP_UNION) ? "</span><span style=color:#a3be8c>zunionstore</span><span>" : "</span><span style=color:#a3be8c>zinterstore</span><span>",
</span><span>            dstkey,c->db->id);
</span><span>        server.</span><span style=color:#bf616a>dirty</span><span>++;
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        </span><span style=color:#bf616a>decrRefCount</span><span>(dstobj);
</span><span>        </span><span style=color:#bf616a>addReply</span><span>(c,shared.</span><span style=color:#bf616a>czero</span><span>);
</span><span>        </span><span style=color:#b48ead>if </span><span>(touched)
</span><span>            </span><span style=color:#bf616a>notifyKeyspaceEvent</span><span>(REDIS_NOTIFY_GENERIC,"</span><span style=color:#a3be8c>del</span><span>",dstkey,c->db->id);
</span><span>    }
</span><span>    </span><span style=color:#bf616a>zfree</span><span>(src);
</span></code></pre><p>随后就是收尾工作. 如果目标的坑上已经有值了, 就毫不犹豫的干掉它. 然后再看作为结果的 <code>sorted set</code>. 如果它满足转化为 <code>ziplist</code> 的条件, 就可以把它转化为 <code>ziplist</code>. 后面是一些 <code>hook</code> 的通知, 可以暂时忽略. 如果结果为空, <code>Integer reply</code> 会返回 0, 否则会返回结果中元素的个数.<p>至此大致流程已经结束了. 如同推测的那样, 算法复杂度完美的反映了操作的内部过程和数据结构. 不过, 我们还有几个问题没有解决. <code>zuiFind</code> 中的具体操作是什么, <code>ziplist</code> 又是什么.<h2 id=ge-zhe-ge-zhe><a aria-label="Anchor link for: ge-zhe-ge-zhe" class=zola-anchor href=#ge-zhe-ge-zhe>搁这搁这</a></h2><p>这个标题充分提现了递归的思想. 学习新东西, 然后发现另一些新东西, 然后再学习这些新东西, 然后......<p>首先来看 <code>zuiFind</code><pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#65737e>/* https://github.com/redis/redis/blob/3.0/src/t_zset.c#L1826 */
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>zuiFind</span><span>(zsetopsrc *</span><span style=color:#bf616a>op</span><span>, zsetopval *</span><span style=color:#bf616a>val</span><span>, </span><span style=color:#b48ead>double </span><span>*</span><span style=color:#bf616a>score</span><span>) {
</span><span>    </span><span style=color:#b48ead>if </span><span>(op->subject == </span><span style=color:#d08770>NULL</span><span>)
</span><span>        </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>
</span><span>    </span><span style=color:#b48ead>if </span><span>(op->type == REDIS_SET) {
</span><span>        </span><span style=color:#b48ead>if </span><span>(op->encoding == REDIS_ENCODING_INTSET) {
</span><span>            </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>zuiLongLongFromValue</span><span>(val) &&
</span><span>                </span><span style=color:#bf616a>intsetFind</span><span>(op->subject->ptr,val->ell))
</span><span>            {
</span><span>                *score = </span><span style=color:#d08770>1.0</span><span>;
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>1</span><span>;
</span><span>            } </span><span style=color:#b48ead>else </span><span>{
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>            }
</span><span>        } </span><span style=color:#b48ead>else if </span><span>(op->encoding == REDIS_ENCODING_HT) {
</span><span>            dict *ht = op->subject->ptr;
</span><span>            </span><span style=color:#bf616a>zuiObjectFromValue</span><span>(val);
</span><span>            </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>dictFind</span><span>(ht,val->ele) != </span><span style=color:#d08770>NULL</span><span>) {
</span><span>                *score = </span><span style=color:#d08770>1.0</span><span>;
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>1</span><span>;
</span><span>            } </span><span style=color:#b48ead>else </span><span>{
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>            }
</span><span>        } </span><span style=color:#b48ead>else </span><span>{
</span><span>            </span><span style=color:#bf616a>redisPanic</span><span>("</span><span style=color:#a3be8c>Unknown set encoding</span><span>");
</span><span>        }
</span><span>    } </span><span style=color:#b48ead>else if </span><span>(op->type == REDIS_ZSET) {
</span><span>        </span><span style=color:#bf616a>zuiObjectFromValue</span><span>(val);
</span><span>
</span><span>        </span><span style=color:#b48ead>if </span><span>(op->encoding == REDIS_ENCODING_ZIPLIST) {
</span><span>            </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>zzlFind</span><span>(op->subject->ptr,val->ele,score) != </span><span style=color:#d08770>NULL</span><span>) {
</span><span>                </span><span style=color:#65737e>/* Score is already set by zzlFind. */
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>1</span><span>;
</span><span>            } </span><span style=color:#b48ead>else </span><span>{
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>            }
</span><span>        } </span><span style=color:#b48ead>else if </span><span>(op->encoding == REDIS_ENCODING_SKIPLIST) {
</span><span>            zset *zs = op->subject->ptr;
</span><span>            dictEntry *de;
</span><span>            </span><span style=color:#b48ead>if </span><span>((de = </span><span style=color:#bf616a>dictFind</span><span>(zs->dict,val->ele)) != </span><span style=color:#d08770>NULL</span><span>) {
</span><span>                *score = *(</span><span style=color:#b48ead>double</span><span>*)</span><span style=color:#bf616a>dictGetVal</span><span>(de);
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>1</span><span>;
</span><span>            } </span><span style=color:#b48ead>else </span><span>{
</span><span>                </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>            }
</span><span>        } </span><span style=color:#b48ead>else </span><span>{
</span><span>            </span><span style=color:#bf616a>redisPanic</span><span>("</span><span style=color:#a3be8c>Unknown sorted set encoding</span><span>");
</span><span>        }
</span><span>    } </span><span style=color:#b48ead>else </span><span>{
</span><span>        </span><span style=color:#bf616a>redisPanic</span><span>("</span><span style=color:#a3be8c>Unsupported type</span><span>");
</span><span>    }
</span><span>}
</span></code></pre><p>先忽略掉 <code>set</code> 的操作, 来看 <code>sorted set</code>. 我们又见到了收尾工作时出现过的 <code>ziplist</code>.<blockquote><p>The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time. However, because every operation requires a reallocation of the memory used by the ziplist, the actual complexity is related to the amount of memory used by the ziplist.</blockquote><p>查了一下资料, 这是 <code>Redis</code> 在面对小元素时可以做的一个内存优化, 本体是一个经过特殊编码的双向链表. 经过特殊编码后的数据会变得更加紧凑, 连续的内存使用也对于缓存更加友好. 有两个配置决定了 <code>sorted set</code> 中使用 <code>ziplist</code> 的阈值.<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#b48ead>#define </span><span>REDIS_ZSET_MAX_ZIPLIST_ENTRIES </span><span style=color:#d08770>128
</span><span style=color:#b48ead>#define </span><span>REDIS_ZSET_MAX_ZIPLIST_VALUE </span><span style=color:#d08770>64
</span></code></pre><p><img alt=有序集合 src=https://memwey.github.io/posts/redis-zinterstore/images/zset.svg> 图. 有序集合<p>然后我们尴尬的发现, 在 <code>ziplist</code> 查找一个元素实际上是一个遍历, 时间复杂度为 <code>O(N)</code>, 如下<pre class=language-C data-lang=C style=color:#c0c5ce;background-color:#2b303b><code class=language-C data-lang=C><span style=color:#65737e>/* https://github.com/redis/redis/blob/3.0/src/t_zset.c#L915 */
</span><span>
</span><span style=color:#b48ead>unsigned char </span><span>*</span><span style=color:#8fa1b3>zzlFind</span><span>(</span><span style=color:#b48ead>unsigned char </span><span>*</span><span style=color:#bf616a>zl</span><span>, robj *</span><span style=color:#bf616a>ele</span><span>, </span><span style=color:#b48ead>double </span><span>*</span><span style=color:#bf616a>score</span><span>) {
</span><span>    </span><span style=color:#b48ead>unsigned char </span><span>*eptr = </span><span style=color:#bf616a>ziplistIndex</span><span>(zl,</span><span style=color:#d08770>0</span><span>), *sptr;
</span><span>
</span><span>    ele = </span><span style=color:#bf616a>getDecodedObject</span><span>(ele);
</span><span>    </span><span style=color:#b48ead>while </span><span>(eptr != </span><span style=color:#d08770>NULL</span><span>) {
</span><span>        sptr = </span><span style=color:#bf616a>ziplistNext</span><span>(zl,eptr);
</span><span>        </span><span style=color:#bf616a>redisAssertWithInfo</span><span>(</span><span style=color:#d08770>NULL</span><span>,ele,sptr != </span><span style=color:#d08770>NULL</span><span>);
</span><span>
</span><span>        </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>ziplistCompare</span><span>(eptr,ele->ptr,</span><span style=color:#bf616a>sdslen</span><span>(ele->ptr))) {
</span><span>            </span><span style=color:#65737e>/* Matching element, pull out score. */
</span><span>            </span><span style=color:#b48ead>if </span><span>(score != </span><span style=color:#d08770>NULL</span><span>) *score = </span><span style=color:#bf616a>zzlGetScore</span><span>(sptr);
</span><span>            </span><span style=color:#bf616a>decrRefCount</span><span>(ele);
</span><span>            </span><span style=color:#b48ead>return</span><span> eptr;
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#65737e>/* Move to next element. */
</span><span>        eptr = </span><span style=color:#bf616a>ziplistNext</span><span>(zl,sptr);
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#bf616a>decrRefCount</span><span>(ele);
</span><span>    </span><span style=color:#b48ead>return </span><span style=color:#d08770>NULL</span><span>;
</span><span>}
</span></code></pre><p>不过当 <code>zset</code> 使用 <code>REDIS_ENCODING_SKIPLIST</code> 作为 encoding 的时候, 使用 <code>Hash table</code> 做查询的时间复杂度是 <code>O(1)</code> 这是肯定的.<p>当然, 这里面其实还有很多细节没有说到, 比如 <code>ziplist</code> 的内部表示, 和 <code>zset</code> 混在一起的 <code>set</code>, <code>zset</code> 中的 <code>dict</code> 和 <code>skiplist</code> 的详细分析等等. 下次有机会的吧.<h2 id=can-kao-zi-liao><a aria-label="Anchor link for: can-kao-zi-liao" class=zola-anchor href=#can-kao-zi-liao>参考资料</a></h2><ol><li><a href=https://redislabs.com/ebook/part-2-core-concepts/01chapter-9-reducing-memory-use/9-1-short-structures/9-1-1-the-ziplist-representation/>The ziplist representation</a><li><a href=https://redisbook.readthedocs.io/en/latest/compress-datastruct/ziplist.html>压缩列表 — Redis 设计与实现</a></ol></section></article></main></div></div><div class=right-content><div class=toc><div class=heading>Table of Contents</div><ul class=toc-list><li class=parent><a href=https://memwey.github.io/posts/redis-zinterstore/#jie-gou-tui-ce>结构推测</a><li class=parent><a href=https://memwey.github.io/posts/redis-zinterstore/#yuan-ma-fen-xi>源码分析</a><li class=parent><a href=https://memwey.github.io/posts/redis-zinterstore/#ge-zhe-ge-zhe>搁这搁这</a><li class=parent><a href=https://memwey.github.io/posts/redis-zinterstore/#can-kao-zi-liao>参考资料</a></ul></div></div>